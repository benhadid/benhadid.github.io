---
type: lab
date: 2019-09-19T4:00:00+4:30
title: 'Travaux Pratiques #7 - Unité Arithmétique et Logique'
#attachment: /static_files/labs/lab.zip
#solutions: /static_files/labs/lab_solutions.pdf
due_event: 
    type: due
    date: 2019-09-26T23:59:00+3:30
    description: 'Travaux Pratiques #7 - à remettre'
---


# Objectifs

- Apprendre le fonctionnement de l'unité arithmétique et logique dans un processeur
- Apprendre à modéliser des circuits logiques avancés avec Logisim

# Énoncé

Pour ce mini-projet, vous utiliserez [Logisim](https://fr.wikipedia.org/wiki/Logisim) afin d'implémenter un version basique d'un processeur MIPS. Ce devoir est organisé en deux parties : A et B.

Dans la partie A (tâches 1 à 3), vous allez construire une « Unité Arithmétique et Logique (UAL) » et un « Banc de Registres » pour un processeur MIPS basique, ainsi qu'une implémentation du chemin de données nécessaire à l'éxecution des instructions `addi`. Dans la partie B (tâches 4 et 5), vous ajouterez d’autres composants à votre processeur basique pour produire une version avancée qui exécutera des instructions MIPS réelles !

Commencez par télécharger le fichier de démarrage (voir plus haut dans ce document) et décompressez son contenu dans le répertoire de votre choix. Voici la liste des fichiers que vous devez avoir :

```shell
alu_starter
  ├── alu.circ
  ├── alu_harness.circ
  ├── tests
  │   ├── alu_add.circ
  │   ├── alu_add.out
  │   ├── alu_mult.circ
  │   ├── alu_mult.out
  │   ├── alu_shift.circ
  │   ├── alu_shift.out
  │   ├── config.json
  │   ├── logisim-evolution.jar
  │   └── test.py
  └── test.sh
 ```

<div class="bs-callout bs-callout-danger">
 <b>REMARQUE</b> : Seul le fichier <b>alu.circ</b> doit être modifié et soumis à l'évaluateur automatique.
</div>

# Partie A : Version basique

## Tâche 1 : Unité Arithmétique et logique (UAL)

Votre première tâche est de créer une UAL qui prend en charge toutes les opérations requises par les instructions de notre ISA (décrite plus en détail dans la section suivante). 

le fichier sequelette fourni `alu.circ` montre que votre UAL doit avoir trois entrées :

<table>
<colgroup>
<col width="15%" />
<col width="15%" />
<col width="70%" />
</colgroup>
<thead>
<tr class="header">
<th>Nom de l'entrée</th>
<th>Largeur en bits</th>
<th style="text-align:left" >Description</th>
</tr>
</thead>
<tbody>

<tr>
<td style="text-align:center" markdown="span">**A**</td>
<td style="text-align:center" markdown="span">32</td>
<td markdown="span">Données sur l'entrée A pour l'opération UAL</td>
</tr>

<tr>
<td style="text-align:center" markdown="span">**B**</td>
<td style="text-align:center" markdown="span">32</td>
<td markdown="span">Données sur l'entrée B pour l'opération UAL</td>
</tr>

<tr>
<td style="text-align:center" markdown="span">**ALUSel**</td>
<td style="text-align:center" markdown="span">4</td>
<td markdown="span">Sélectionne quelle opération l'UAL doit effectuer (voir ci-dessous pour la liste des opérations avec les valeurs correspondantes du commutateur).</td>
</tr>
</tbody>
</table>

... et une sortie

<table>
<colgroup>
<col width="15%" />
<col width="15%" />
<col width="70%" />
</colgroup>
<thead>
<tr class="header">
<th>Nom de la sortie</th>
<th>Largeur en bits</th>
<th style="text-align:left" >Description</th>
</tr>
</thead>
<tbody>

<tr>
<td style="text-align:center" markdown="span">**Result**</td>
<td style="text-align:center" markdown="span">32</td>
<td markdown="span">Résultat de l'opération UAL</td>
</tr>
</tbody>
</table>

**REMARQUES** : Dans les slides du cours &laquo; [Architecture de Von Neumann](https://1drv.ms/p/s!Agf0g-qZKM8_yAyyv1se7-WxjsN2?e=GO7udR) &raquo;, et afin de construire une UAL de plusieurs bits (8 bits est donné comme exemple), il est indiqué de dupliquer votre circuit de 1 bit et faire les adaptations nécessaires pour obtenir une UAL de plusieurs bits. Bonne nouvelle ! vous n'avez pas à le faire dans ce TP, Logisim fait déjà cela pour vous ! Il suffit simplement de choisir la bonne largeur de bits pour les entrées/sorties de vos composants et c'est tout (voir la figure ci-dessous) !

 ![Largeur de bits]({{site.baseurl}}/static_files/images/data_width.png){: height="55%" width="55%" .wp-caption .aligncenter}

Enfin, voici ci-dessous la liste des opérations (ainsi que leurs valeurs **ALUSel** associées) que votre UAL doit pouvoir effectuer. Vous pouvez utiliser tout bloc ou fonction intégrée de Logisim pour implémenter votre circuit. **Il n'est pas nécessaire de réimplémenter le circuit additionneur, de décalage ou le circuit multiplicateur à partir de zéro ! Utilisez les blocs de circuit fournis par Logisim à cet effet**.

<table>
<colgroup>
<col width="20%" />
<col width="20%" />
<col width="35%" />
<col width="25%" />
</colgroup>
<thead>
<tr class="header">
<th>Valeur de ALUSel</th>
<th>Instruction</th>
<th style="text-align:left">Description</th>
<th style="text-align:left">Remarque</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center" markdown="span">0</td>
<td style="text-align:left" markdown="span">&emsp;&emsp;add</td>
<td markdown="span">`Result = A + B`</td>
<td markdown="span"></td>
</tr>

<tr>
<td style="text-align:center" markdown="span">1</td>
<td style="text-align:left" markdown="span">&emsp;&emsp;and</td>
<td markdown="span">`Result = A & B`</td>
<td markdown="span"></td>
</tr>

<tr>
<td style="text-align:center" markdown="span">2</td>
<td style="text-align:left" markdown="span">&emsp;&emsp;or</td>
<td markdown="span">`Result = A | B`</td>
<td markdown="span"></td>
</tr>

<tr>
<td style="text-align:center" markdown="span">3</td>
<td style="text-align:left" markdown="span">&emsp;&emsp;xor</td>
<td markdown="span">`Result = A ^ B`</td>
<td markdown="span"></td>
</tr>

<tr>
<td style="text-align:center" markdown="span">4</td>
<td style="text-align:left" markdown="span">&emsp;&emsp;srl</td>
<td markdown="span">`Result = A >> B`</td>
<td markdown="span">Opération non signée</td>
</tr>

<tr>
<td style="text-align:center" markdown="span">5</td>
<td style="text-align:left" markdown="span">&emsp;&emsp;sra</td>
<td markdown="span">`Result = A >> B`</td>
<td markdown="span">Opération signée</td>
</tr>

<tr>
<td style="text-align:center" markdown="span">6</td>
<td style="text-align:left" markdown="span">&emsp;&emsp;sll</td>
<td markdown="span">`Result = A << B`</td>
<td markdown="span"></td>
</tr>

<tr>
<td style="text-align:center" markdown="span">7</td>
<td style="text-align:left" markdown="span">&emsp;&emsp;slt</td>
<td markdown="span">`Result = A < B ? 1 : 0`</td>
<td markdown="span">Comparaison signée</td>
</tr>

<tr>
<td style="text-align:center" markdown="span">8</td>
<td style="text-align:left" markdown="span">&emsp;&emsp;&mdash;</td>
<td markdown="span">&emsp;&emsp;&mdash;</td>
<td markdown="span">Non utilisé</td>
</tr>

<tr>
<td style="text-align:center" markdown="span">9</td>
<td style="text-align:left" markdown="span">&emsp;&emsp;&mdash;</td>
<td markdown="span">&emsp;&emsp;&mdash;</td>
<td markdown="span">Non utilisé</td>
</tr>

<tr>
<td style="text-align:center" markdown="span">10</td>
<td style="text-align:left" markdown="span">&emsp;&emsp;mul</td>
<td markdown="span">`Result = (A * B)[31:0]`</td>
<td markdown="span">Opération signée</td>
</tr>

<tr>
<td style="text-align:center" markdown="span">11</td>
<td style="text-align:left" markdown="span">&emsp;&emsp;mulhu</td>
<td markdown="span">`Result = (A * B)[63:32]`</td>
<td markdown="span"></td>
</tr>

<tr>
<td style="text-align:center" markdown="span">12</td>
<td style="text-align:left" markdown="span">&emsp;&emsp;sub</td>
<td markdown="span">`Result = A - B`</td>
<td markdown="span"></td>
</tr>

<tr>
<td style="text-align:center" markdown="span">13</td>
<td style="text-align:left" markdown="span">&emsp;&emsp;bsel</td>
<td markdown="span">`Result = B`</td>
<td markdown="span"></td>
</tr>

<tr>
<td style="text-align:center" markdown="span">14</td>
<td style="text-align:left" markdown="span">&emsp;&emsp;mulh</td>
<td markdown="span">`Result = (A * B)[63:32]`</td>
<td markdown="span">Opération signée</td>
</tr>
</tbody>
</table>


**Indications** :

  * L'opération `add` est déjà implémentée pour vous; n'hésitez pas à utiliser une structure similaire pour réaliser les autres composants.    

  * Lors de l'implémentation de `mul` et `mulh`, veuillez noter que le bloc Logisim de multiplication possède une sortie « Carry Out » (le bloc additionneur possède également cette sortie, mais vous n'en aurez pas besoin).

  * Les séparateurs et les extendeurs de bits vous seront très utiles lors de l'implémentation des opérations `sra` et `srl`.

  * Utilisez les tunnels ! Cela vous évitera de croiser des fils involantairement ce qui causera des erreurs inattendues.

  * Un multiplexeur (MUX) peut être utile pour décider quel résultat de quel composant vous voulez sortir. En d'autres termes, traiter les entrées dans tous les composants d'une manière simultanée, puis, en fonction de l'opération choisie, séléctionner la bonne sortie à transmettre.

  
<div class="bs-callout bs-callout-danger">
  <h4>ATTENTION</h4>

  <p>Vous pouvez apporter toutes les modifications souhaitées à <b>alu.circ</b>, mais les entrées et la sortie doivent obéir au comportement spécifié ci-dessus. De plus, votre fichier <b>alu.circ</b> doit correspondre au socle <b>alu_harness.circ</b> fourni. Cela signifie que vous devez veiller à <b>NE PAS</b> réorganiser les entrées ou la sortie du circuit. Si vous avez besoin de plus d'espace, utilisez des tunnels !</p>

  <p>Si vous créez des sous-circuits supplémentaires, ils doivent également être dans <b>alu.circ</b> (c.-à-d. vous ne devez pas créer de nouveaux fichiers .circ).</p> 

  <p>Pour vérifier que vos modifications n’ont pas rompu les correspondances entrés/sorties entre les deux circuits, ouvrez le fichier <b>alu_harness.circ</b> et assurez-vous qu’il n’y a pas d’erreurs de branchement.</p>
</div>

### **Tester votre UAL**

Un groupe de tests de cohérence UAL est fourni dans le répertoire `tests/part_a/alu`. L'exécution du testeur (voir ci-dessous) pour ce groupe exécutera les tests UAL et produira le résultat des tests dans le répertoire `tests/part_a/alu/student_output`. 

```bash
$ python3 test_runner.py part_a alu
```

Egalement fourni est le fichier `binary_to_hex_alu.py` qui permet d'interpréter cette sortie dans un format lisible pour vous. Pour l'utiliser, procédez comme suit :

```bash
$ cd tests/part_a/alu
$ python3 binary_to_hex_alu.py PATH_TO_OUTPUT_FILE
```

Par exemple, pour visualiser le fichier `reference_output/alu-add-ref.out` dans un format lisible, procédez comme suit :

```bash
$ cd tests/part_a/alu
$ python3 binary_to_hex_alu.py reference_output/alu-add-ref.out
```

Si vous voulez voir la différence entre la sortie de votre circuit et la solution de référence, placez les sorties lisibles dans de nouveaux fichiers `.out` et comparez-les avec la commande `diff` (cf. `man diff`). Par exemple, pour le test `alu-add`, procédez comme suit :

```bash
$ cd tests/part_a/alu
$ python3 binary_to_hex_alu.py reference_output/alu-add-ref.out > reference.out
$ python3 binary_to_hex_alu.py student_output/alu-add-student.out > student.out
$ diff reference.out student.out
```

## Tâche 2 : Banc de Registres

Dans cette tâche, vous implémenterez les 32 registres spécifiés dans l'architecture MIPS. Pour faciliter l'implémentation, neuf registres seront exposés à des fins de test et de débogage (voir la liste ci-dessous). Veuillez vous assurer que les valeurs de ces registres sont attachées aux sorties appropriées dans le fichier `RegFile.circ`.

Votre « Banc de Registres » devrait pouvoir lire ou écrire depuis/dans les registres spécifiés dans une instruction MIPS et cela sans affecter les autres registres. Il y a une exception notable : votre « Banc de Registres » ne doit **PAS** écrire dans le registre `$0` même si une instruction tente de le faire. Pour rappel, le registre zéro doit **TOUJOURS** avoir la valeur `0x0`.

Les registres exposés et leurs numéros correspondants sont indiqués ci-dessous.

<table>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<thead>
<tr class="header">
<th>Numéro de registre</th>
<th>Nom du registre</th>
</tr>
</thead>
<tbody>

<tr>
<td style="text-align:center" markdown="span">0</td>
<td style="text-align:center" markdown="span">$0</td>
</tr>
<tr>
<td style="text-align:center" markdown="span">1</td>
<td style="text-align:center" markdown="span">$ra</td>
</tr>
<tr>
<td style="text-align:center" markdown="span">2</td>
<td style="text-align:center" markdown="span">$sp</td>
</tr>
<tr>
<td style="text-align:center" markdown="span">5</td>
<td style="text-align:center" markdown="span">$t0</td>
</tr>
<tr>
<td style="text-align:center" markdown="span">6</td>
<td style="text-align:center" markdown="span">$t1</td>
</tr>

<tr>
<td style="text-align:center" markdown="span">7</td>
<td style="text-align:center" markdown="span">$t2</td>
</tr>

<tr>
<td style="text-align:center" markdown="span">8</td>
<td style="text-align:center" markdown="span">$s0</td>
</tr>

<tr>
<td style="text-align:center" markdown="span">9</td>
<td style="text-align:center" markdown="span">$s1</td>
</tr>

<tr>
<td style="text-align:center" markdown="span">10</td>
<td style="text-align:center" markdown="span">$a0</td>
</tr>
</tbody>
</table>

<br>
Un squelette du « Banc de Registres » à implémenter est fourni dans le fichier `regfile.circ`. Le circuit possède six entrées :

<table>
<colgroup>
<col width="20%" />
<col width="15%" />
<col width="65%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align:left">Nom de l'entrée</th>
<th>Largeur en bits</th>
<th style="text-align:left" >Description</th>
</tr>
</thead>

<tbody>

<tr>
<td style="text-align:left" markdown="span">**Clock**</td>
<td style="text-align:center" markdown="span">1</td>
<td markdown="span">Entrée fournissant l'horloge. Ce signal peut être acheminé à d'autres sous-circuits ou directement raccordé aux entrées d’horloge des unités de mémoire dans Logisim, mais ne doit en aucune façon être raccordé à des portes logiques (c.-à-d. ne l’inversez pas, n'appliquez pas la porte "ET" dessus, etc.)</td>
</tr>

<tr>
<td style="text-align:left" markdown="span">**RegWEn**</td>
<td style="text-align:center" markdown="span">1</td>
<td markdown="span">Active l'écriture des données au prochain front montant de l'horloge</td>
</tr>

<tr>
<td style="text-align:left" markdown="span">**Read Register 1** (rs1)</td>
<td style="text-align:center" markdown="span">5</td>
<td markdown="span">Détermine quelle valeur de registre est envoyée à la sortie **Read Data 1**, voir ci-dessous</td>
</tr>

<tr>
<td style="text-align:left" markdown="span">**Read Register 2** (rs2)</td>
<td style="text-align:center" markdown="span">5</td>
<td markdown="span">Détermine quelle valeur de registre est envoyée à la sortie **Read Data 2**, voir ci-dessous</td>
</tr>

<tr>
<td style="text-align:left" markdown="span">**Write Register** (rd)</td>
<td style="text-align:center" markdown="span">5</td>
<td markdown="span">Sélectionne le registre qui recevera le contenu de **Write Data** au prochain front montant de l'horloge, en supposant que **RegWEn** est à 1</td>
</tr>

<tr>
<td style="text-align:left" markdown="span">**Write Data**</td>
<td style="text-align:center" markdown="span">32</td>
<td markdown="span">Contient les données à écrire dans le registre identifié par l'entrée **Write Register** au prochain front montant de l'horloge, en supposant que **RegWEn** est à 1</td> 
</tr>
</tbody>
</table>

<br>
Le « Banc de Registres » dans `regfile.circ` possède également les sorties suivantes :

<table>
<colgroup>
<col width="15%" />
<col width="15%" />
<col width="70%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align:left">Nom de la sortie</th>
<th>Largeur en bits</th>
<th style="text-align:left" >Description</th>
</tr>
</thead>

<tbody>

<tr>
<td style="text-align:left" markdown="span">&emsp;**rs1**</td>
<td style="text-align:center" markdown="span">32</td>
<td markdown="span">Renvoie la valeur contenue dans le registre identifié par l'entrée **Read Register 1**</td>
</tr>

<tr>
<td style="text-align:left" markdown="span">&emsp;**rs2**</td>
<td style="text-align:center" markdown="span">32</td>
<td markdown="span">Renvoie la valeur contenue dans le registre identifié par l'entrée **Read Register 2**</td>
</tr>

<tr>
<td style="text-align:left" markdown="span">&emsp;Valeur **ra**</td>
<td style="text-align:center" markdown="span">32</td>
<td markdown="span">Renvoie la valeur contenue dans le registre **$ra** (sortie utilisée pour le débogage et les tests)</td>
</tr>

<tr>
<td style="text-align:left" markdown="span">&emsp;Valeur **sp**</td>
<td style="text-align:center" markdown="span">32</td>
<td markdown="span">Renvoie la valeur contenue dans le registre **$sp** (sortie utilisée pour le débogage et les tests)</td>
</tr>

<tr>
<td style="text-align:left" markdown="span">&emsp;Valeur **t0**</td>
<td style="text-align:center" markdown="span">32</td>
<td markdown="span">Renvoie la valeur contenue dans le registre **$t0** (sortie utilisée pour le débogage et les tests)</td>
</tr>

<tr>
<td style="text-align:left" markdown="span">&emsp;Valeur **t1**</td>
<td style="text-align:center" markdown="span">32</td>
<td markdown="span">Renvoie la valeur contenue dans le registre **$t1** (sortie utilisée pour le débogage et les tests)</td>
</tr>

<tr>
<td style="text-align:left" markdown="span">&emsp;Valeur **t2**</td>
<td style="text-align:center" markdown="span">32</td>
<td markdown="span">Renvoie la valeur contenue dans le registre **$t2** (sortie utilisée pour le débogage et les tests)</td>
</tr>

<tr>
<td style="text-align:left" markdown="span">&emsp;Valeur **s0**</td>
<td style="text-align:center" markdown="span">32</td>
<td markdown="span">Renvoie la valeur contenue dans le registre **$s0** (sortie utilisée pour le débogage et les tests)</td>
</tr>

<tr>
<td style="text-align:left" markdown="span">&emsp;Valeur **s1**</td>
<td style="text-align:center" markdown="span">32</td>
<td markdown="span">Renvoie la valeur contenue dans le registre **$s1** (sortie utilisée pour le débogage et les tests)</td>
</tr>

<tr>
<td style="text-align:left" markdown="span">&emsp;Valeur **s2**</td>
<td style="text-align:center" markdown="span">32</td>
<td markdown="span">Renvoie la valeur contenue dans le registre **$s2** (sortie utilisée pour le débogage et les tests)</td>
</tr>
</tbody>
</table>

<br>

Les sorties de test en haut du fichier `regfile.circ` sont présentes à des fins de test et de débogage. Un « Banc de Registres » réel ne possède pas ces sorties ! Pour ce mini-projet, assurez-vous qu'ils sont correctement raccordés aux registres indiqués parce que s'ils ne le sont pas, l'évaluateur automatique ne pourra pas évaluer votre devoir correctement ( et vous obtiendrez un zéro. :( ).

**Indications** :

  * Utilisez le copier-coller à volonté ! Afin d'éviter un travail répétitif (et ennuyeux), commencez par créer un registre complètement fonctionnel et utiliser le ensuite comme modèle pour construire les autres.

  * Il est recommendé de ne pas utiliser l'entrée « `enable` » sur vos MUX. En fait, vous pouvez même désactiver cette fonctionnalité depuis le panel Logisim. Il est également conseillé de mettre sur « `off` » la propriété "three-state?". 
  
  * Consultez l'étape 2 du TP [Traveaux Pratiques #7 - Introduction à Logisim]({{site.baseurl}}/labs/07_lab.html) pour voir à quoi correspond chaque entrée/sortie d'un registre Logisim.

  * Comme pour la tâche de l'UAL, les multiplexeurs vous seront très utiles (les démultiplexeurs, également).

  * Que se passe-t-il dans le « Banc de registres » après l'exécution d'une instruction machine. Quelles valeurs changent ? Quelles valeurs restent les mêmes ? Les registres sont déclenchés par une horloge - qu'est-ce que cela signifie ?

  * Pour rappel, les registres possèdent une entrée « `enable` » ainsi qu'une entrée d'horloge.

  * Quelle est la valeur du registre `$0` ?
  

<div class="bs-callout bs-callout-danger">
  <h4>ATTENTION</h4>

  <p>Vous pouvez apporter toutes les modifications souhaitées à <b>regfile.circ</b>, mais les entrées et la sortie doivent obéir au comportement spécifié ci-dessus. De plus, votre fichier <b>regfile.circ</b> doit correspondre au socle <b>regfile_harness.circ</b> fourni. Cela signifie que vous devez veiller à <b>NE PAS</b> réorganiser les entrées ou les sorties du circuit. Si vous avez besoin de plus d'espace, utilisez des tunnels !</p>

  <p>Si vous créez des sous-circuits supplémentaires, ils doivent également être dans <b>regfile.circ</b> (c.-à-d. vous ne devez pas créer de nouveaux fichiers .circ).</p> 

  <p>Pour vérifier que vos modifications n’ont pas rompu les correspondances entrés/sorties entre les deux circuits, ouvrez le fichier <b>regfile_harness.circ</b> et assurez-vous qu’il n’y a pas d’erreurs de branchement.</p>
</div>

### **Tester votre « Banc de registres »**

Un groupe de tests de cohérence du « Banc de registres » est fourni dans le répertoire `tests/part_a/regfile`. L'exécution du testeur (voir ci-dessous) pour ce groupe exécutera également les tests UAL et produira le résultat des tests dans le répertoire `tests/part_a/regfile/student_output`. 

```bash
$ python3 test_runner.py part_a regfile
```

Egalement fourni est le fichier `binary_to_hex_regfile.py` qui fonctionne d'une manière similaire au fichier `binary_to_hex_alu.py` de la tâche n°1.

## Tâche 3 : L'instruction `addi`

Dans cette troisième et dernière tâche pour la partie A, vous allez implémenter un processeur capable d’exécuter une instruction : `addi` ! Vous pouvez choisir d'implémenter d'autres instructions supplémentaires, mais vous ne serez noté que si l'instruction `addi` s'exécute correctement pour la partie A. Vous obtiendrez des instructions plus détaillées sur la manière de mettre en oeuvre les autres instructions lorsque la partie B du projet sera publiée.

### Info : Mémoire (circuit `mem.circ`)

L'unité de mémoire (fournie dans `mem.circ`) est déjà entièrement implémentée pour vous ! Cependant, l'instruction addi n'utilise **PAS** l'unité de mémoire, vous pouvez donc ignorer ce module pour la partie A.

### Info : Comparateur de Branchement (circuit `branch_comp.circ`)

L'unité « Comparateur de Branchement » fournie dans le fichier `branch_comp.circ` n'est pas implémentée, mais comme l'instruction `addi` n'utilise **PAS** cette unité vous pouvez donc l'ignorer pour la partie A.

### Info : Générateur d'Immediat (circuit `imm_gen.circ`)

l'unité « Générateur d'Immédiat » fournie dans le fichier `imm_gen.circ` n'est pas implémentée. L'instruction `addi` utilise cette unité. Toutefois, comme il s'agit de la seule instruction à implémenter dans cette partie du projet, vous pouvez donc vous limiter à coder que l'immediat associé à cette instruction sans vous soucier des autres types d'immédiat. Consultez l'image ci-dessous pour savoir comment l'immédiat de l'instruction `addi` doit être généré :

![addi Format Immediat]({{site.baseurl}}/static_files/images/immediat_addi.png){: height="75%" width="75%" .aligncenter}

Pour éditer le « Générateur d'Immédiat », modifiez le fichier `imm_gen.circ` et non le circuit virtuel `imm_gen` inclus dans `cpu.circ`. Notez qu'à chaque modification du circuit `imm_gen.circ`, vous devez fermer et ouvrir le fichier `cpu.circ` pour charger les modifications dans votre CPU.

Voici un résumé des entrées et sorties de l'unité :

<table>
<colgroup>
<col width="10%" />
<col width="10%" />
<col width="20%" />
<col width="60%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align:left">Nom</th>
<th>Direction</th>
<th>Largeur en bits</th>
<th style="text-align:left" >Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left" markdown="span">inst</td>
<td style="text-align:center" markdown="span">Input</td>
<td style="text-align:center" markdown="span">32</td>
<td markdown="span">L'instruction en cours d'exécution</td>
</tr>
<tr>
<td style="text-align:left" markdown="span">ImmSel</td>
<td style="text-align:center" markdown="span">Input</td>
<td style="text-align:center" markdown="span">3</td>
<td markdown="span">Valeur déterminant comment reconstruire l'immédiat</td>
</tr>
<tr>
<td style="text-align:left" markdown="span">Imm</td>
<td style="text-align:center" markdown="span">Output</td>
<td style="text-align:center" markdown="span">32</td>
<td markdown="span">Valeur de l'immédiat associé à l'instruction</td>
</tr>
</tbody>
</table>

<br>

### Info: Processeur (circuit `cpu.circ`)

Le kit de démarrage fournit également un squelette pour votre processeur dans `cpu.circ`. Vous utiliserez vos propres implémentations de l'UAL et du « Banc de registres » lorsque vous construirez votre chemin de données. Pour la partie A, votre processeur doit pouvoir exécuter l'instruction `addi` en utilisant un « pipeline » à deux étages, avec IF dans la première étape et ID, EX, MEM et WB dans la deuxième étape. Pour commencer, cependant, il est recommandé de construire un processeur sans « pipeline ». Une fois c'est fait, vous pouvez modifier votre processeur afin qu'il dispose d'un « pipeline » en deux étapes.

Votre processeur est inséré dans le socle `test_harness.circ` qui contient l'unité de mémoire. Ce socle de processeur est inséré à son tour dans le socle de test `run.circ` qui fournit les instructions au processeur. 

En sortie, votre processeur émettra l'adresse d'une instruction à récupérer depuis la mémoire. L'instruction solicitée est transmise ensuite au processeur dans l'entrée appropriée.

En sortie également, le processeur émettra l'adresse d'une donnée en mémoire et éventuellement un signal d'activation de l'écriture de données en mémoire. Pour la lecture, les données récupérées depuis l'adresse transmise seront communiquées au processeur dans l'entrée appropriée. 

Essentiellement, les socles `test_harness.circ` et `run.circ` simulent respectivement vos mémoires de données et d'instructions. Prenez le temps de vous familiariser avec leur fonctionnement pour vous faire une idée globale sur le simulateur. 

<div class="bs-callout bs-callout-danger">
  <h4>ATTENTION</h4>

<p>le socle <b>test_harness.circ</b> sera utilisé dans les tests de cohérence qui vous sont fournis, assurez-vous donc que votre processeur <b>cpu.circ</b> s'insère correctement dans ce socle avant de tester votre implémentation et particulièrement lorsque vous soumettez votre travail pour évaluation</p>

<p>Tout comme avec l'UAL et le « Banc de registres », veillez à <b>NE PAS</b> déplacer les ports d'entrée ou de sortie !</p>
</div>

Le processeur dispose de trois entrées qui proviennent du socle :

<table>
<colgroup>
<col width="15%" />
<col width="15%" />
<col width="70%" />
</colgroup>
<thead>
<tr class="header">
<th>Nom de l'entrée</th>
<th>Largeur en bits</th>
<th style="text-align:left" >Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center" markdown="span">READ_DATA</td>
<td style="text-align:center" markdown="span">32</td>
<td markdown="span">Données récupérées depuis la mémoire de données à l'adresse indiquée dans WRITE_ADDRESS (voir ci-dessous).</td>
</tr>
<tr>
<td style="text-align:center" markdown="span">INSTRUCTION</td>
<td style="text-align:center" markdown="span">32</td>
<td markdown="span">L'instruction récupérée depuis la mémoire d'instructions à l'adresse indiquée par FETCH_ADDRESS (voir ci-dessous).</td>
</tr>
<tr>
<td style="text-align:center" markdown="span">CLOCK</td>
<td style="text-align:center" markdown="span">1</td>
<td markdown="span">Entrée fournissant l'horloge. Comme déjà indiquée dans la tâche « Banc de registres », ce signal peut être acheminé à d'autres sous-circuits ou directement raccordé aux entrées d’horloge des unités de mémoire dans Logisim, mais ne doit en aucune façon être raccordé à des portes logiques (c’est-à-dire, ne l’inversez pas, n'appliquez pas la porte "ET" dessus, etc.).</td>
</tr>
</tbody>
</table>

<br>
... et fournit les sorties suivantes pour le socle :

<table>
<colgroup>
<col width="15%" />
<col width="15%" />
<col width="70%" />
</colgroup>
<thead>
<tr class="header">
<th>Nom de la sortie</th>
<th>Largeur en bits</th>
<th style="text-align:left" >Description</th>
</tr>
</thead>
<tbody>

<tr>
<td style="text-align:center" markdown="span">ra</td>
<td style="text-align:center" markdown="span">32</td>      
<td markdown="span">Renvoie la valeur contenue dans le registre $ra (sortie utilisée pour le débogage et les tests)</td>      
</tr>

<tr>
<td style="text-align:center" markdown="span">sp</td>
<td style="text-align:center" markdown="span">32</td>      
<td markdown="span">Renvoie la valeur contenue dans le registre $sp (sortie utilisée pour le débogage et les tests)</td>      
</tr>

<tr>
<td style="text-align:center" markdown="span">t0</td>
<td style="text-align:center" markdown="span">32</td>      
<td markdown="span">Renvoie la valeur contenue dans le registre $t0 (sortie utilisée pour le débogage et les tests)</td>      
</tr>

<tr>
<td style="text-align:center" markdown="span">t1</td>
<td style="text-align:center" markdown="span">32</td>      
<td markdown="span">Renvoie la valeur contenue dans le registre $t1 (sortie utilisée pour le débogage et les tests)</td>      
</tr>

<tr>
<td style="text-align:center" markdown="span">t2</td>
<td style="text-align:center" markdown="span">32</td>      
<td markdown="span">Renvoie la valeur contenue dans le registre $t2 (sortie utilisée pour le débogage et les tests)</td>      
</tr>

<tr>
<td style="text-align:center" markdown="span">s0</td>
<td style="text-align:center" markdown="span">32</td>      
<td markdown="span">Renvoie la valeur contenue dans le registre $s0 (sortie utilisée pour le débogage et les tests)</td>      
</tr>

<tr>
<td style="text-align:center" markdown="span">s1</td>
<td style="text-align:center" markdown="span">32</td>      
<td markdown="span">Renvoie la valeur contenue dans le registre $s1 (sortie utilisée pour le débogage et les tests)</td>      
</tr>

<tr>
<td style="text-align:center" markdown="span">a0</td>
<td style="text-align:center" markdown="span">32</td>      
<td markdown="span">Renvoie la valeur contenue dans le registre $a0 (sortie utilisée pour le débogage et les tests)</td>      
</tr>

<tr>
<td style="text-align:center" markdown="span">WRITE_ADDRESS</td>
<td style="text-align:center" markdown="span">32</td>      
<td markdown="span">L'adresse à partir de laquelle une lecture/écriture depuis/dans la mémoire de données est requise</td>      
</tr>

<tr>
<td style="text-align:center" markdown="span">WRITE_DATA</td>
<td style="text-align:center" markdown="span">32</td>      
<td markdown="span">Données à transmettre à la mémoire de données</td>      
</tr>

<tr>
<td style="text-align:center" markdown="span">WRITE_ENABLE</td>
<td style="text-align:center" markdown="span">4</td>      
<td markdown="span">Fournit le masque de validation d'écriture à la mémoire de données</td>      
</tr>

<tr>
<td style="text-align:center" markdown="span">FETCH_ADDRESS</td>
<td style="text-align:center" markdown="span">32</td>      
<td markdown="span">Cette sortie est utilisée pour sélectionner depuis la mémoire ROM dans <b>run_harness.circ</b> l'instruction à présenter à l'entrée INSTRUCTION (voir ci-dessus) du processeur</td>      
</tr>  
</tbody>
</table>

<br>

### Info : Unité de Contrôle

L'unité de contrôle fournie dans le fichier `control_logic.circ` n'est pas implémentée. La conception de votre unité de contrôle sera probablement votre plus grand défi dans la partie B de ce devoir. Pour la partie A, comme `addi` est la seule instruction que vous implémenterez, vous pouvez mettre une constante pour chaque signal de contrôle. Toutefois, au fur et à mesure que vous avancez dans votre implémentation de `addi`, réfléchissez aux endroits où vous devrez effectuer des modifications/additions afin de prendre en charge d'autres instructions dans le futur.

Pour éditer l'unité de contrôle, modifiez le fichier `control_logic.circ` et non le circuit virtuel `control_logic` inclus dans `cpu.circ`. Notez qu'à chaque modification du circuit `control_logic.circ`, vous devrez fermer et ouvrir `cpu.circ` pour charger les modifications dans votre CPU.
 
<div class="bs-callout bs-callout-danger">
  <h4>ATTENTION</h4>

<p>Pendant l'implémentation de votre unité de contrôle, vous pouvez <b>ajouter</b> des ports d'entrées ou de sorties supplémentaires au circuit de démarrage dans <b>control_logic.circ</b>. Vous pouvez également utiliser les ports déjà fournis (ou un sous ensemble de ces ports) en fonction des besoins de votre implémentation. Cela dit, veuillez <b>ne modifier ni supprimer aucun des ports</b> existants au cours de ce processus.
</p>
</div>

### Guide : Processeur à cycle unique

Il peut être intimidant de commencer à partir d'une ardoise vièrge quand on veut construire un processeur ! 

Rappelons les cinq étapes d'exécution dans un processeur MIPS :

  1. Récupération d'instruction (IF)
  2. Décodage d'instruction (ID)
  3. Exécution de l'instruction (EX)
  4. Lecture/écriture depuis/vers la mémoire de données (MEM)
  5. Ecriture *éventuelle* dans le « Banc de registres » (WB) 


Ce guide vous aidera à implémenter chacune de ces étapes pour l'instruction `addi`. Chaque section ci-dessous contient des questions auxquelles vous devez réfléchir et des indications importantes. Il est nécessaire de lire et comprendre chaque question avant de passer à la suivante ! Vous pouvez même consulter les réponses en cliquant sur  &#9656;  si vous n'êtes pas capables de trouver les réponses vous-mêmes :(.

#### **Etape 1 : Récupération d'instruction (IF)**

A ce stade de l'exécution, la question principale qui se pose est : Comment obtenir l'instruction actuelle ? Nous avons vu dans le cours que les instructions sont stockées dans la mémoire d'instructions, et chacune de ces instructions est accessible via une adresse.

<details close="">
<summary markdown="span">
1. Quel fichier du projet contient votre mémoire d'instructions ? Comment est-elle connectée à votre processeur ?
</summary>
<p style="color: firebrick" markdown="span">
La mémoire d'instructions est le module ROM dans le fichier `run.circ`. Ce fichier fournit une entrée pour votre CPU nommée `INSTRUCTION` et prend une sortie de votre CPU. Cette sortie est appelée` PROGRAM_COUNTER` dans votre fichier `cpu.circ` et elle s'appelle `FETCH_ADDR` dans `run.circ`.
</p>
</details>

<details close="">
<summary markdown="span">
2. Dans votre circuit `cpu.circ`, comment le changement de l'adresse transmise à travers `PROGRAM_COUNTER` affecterait-il l'entrée `INSTRUCTION` ?
</summary>
<p style="color: firebrick" markdown="span">
L'instruction que `run.circ` transmet à votre processeur doit être l'instruction récupérée depuis l'adresse `PROGRAM_COUNTER` (ou `FETCH_ADDR`) dans la mémoire d'instructions.
</p>
</details>

<details close="">
<summary markdown="span">
3. Comment vérifier si `PROGRAM_COUNTER` est correct ?
</summary>
<p style="color: firebrick" markdown="span">
`PROGRAM_COUNTER` est l'adresse de l'instruction en cours d'exécution. Cette adresse est donc sauvegardée dans le registre `PC`. Pour ce projet, votre registre `PC` démarrera à la valeur `0` car c'est la valeur par défaut dans un registre Logisim.
</p>
</details>

<details close="">
<summary markdown="span">
4. Comment le registre `PC` change-t-il pour les programmes simples qui ne possèdent pas d'instructions de sauts ou de branchement ? 
</summary>
<p style="color: firebrick" markdown="span">
Comme le registre `PC` contient l'adresse de l'instruction en cours d'exécution, il faut incrémenter ce registre de la taille d'une instruction pour passer à l'instruction suivante. Cela signifie que votre `PC` augmentera généralement de 4 (en supposant que l'instruction en cours n'est pas un saut ou un branchement).
</p>
</details>
<br>
Une implémentation simple du registre `PC` est fournie dans `cpu.circ`. Cette implémentation ne prend pas en compte les instructions de saut et de branchement que vous implémenterez dans la partie B du projet. Mais pour l'instant, seulement des instructions `addi` seront executées dans notre processeur.

Rappelons que nous allons éventuellement implémenter un processeur en pipeline à 2 étages, de sorte que l'étape IF est séparée des étapes restantes. Quel circuit sépare les différentes étapes d'un pipeline ? Plus précisément, quel circuit sépare IF de l'étage suivant ? Auriez-vous besoin d'ajouter quelque chose ici ?
<br>

#### **Etape 2 : Décodeur d'instruction**

Une fois l'étape « IF » implémentée, l'instruction à traiter proviendra à l'entrée `INSTRUCTION` du processeur. La seconde étape consiste donc à décomposer cette instruction selon les formats d'instruction MIPS vus en cours, et cela afin de déterminer quoi en faire dans les étapes ultérieures d'éxecution.

<details close="">
<summary markdown="span">
1. Quel type d'instruction est `addi` ? Quels sont les différents champs de bits associés à ce type d'instruction et de quels bits de l'instruction chaque champ est constitué ? 
</summary>
<p style="color: firebrick" markdown="span">
`addi` est une instruction de « **type I** ». Les champs de bits sont : - `opcode [31-26]` - `rs [25-21]` - `rt [20-16]` - `imm [15-0]`.</p>
</details>

<details close="">
<summary markdown="span">
2. Dans Logisim, quel outil utiliseriez-vous pour séparer différents groupes de bits ? 
</summary>
<p style="color: firebrick" markdown="span">
Le Séparateur de bits (Splitter) !
</p>
</details>
<br>
&emsp;&nbsp;3\. Implémentez l'étape de « décodage d'instruction » en utilisant l'entrée `INSTRUCTION`. Vous devez utiliser des tunnels pour étiqueter et grouper les bits.
<details close="">
<summary markdown="span">
4. Dans une instruction `addi`, nous avons besoin de lire le contenu d'un registre du « Banc de registres » pour l'additionner à une constante. Quel champ de l'instruction doit être connecté au « Banc de registres » ? À quelle entrée du « Banc de registres » doit-il être branché ?
</summary>
<p style="color: firebrick" markdown="span">
Le champ d'instruction `rs` doit être branché sur l'entrée « read register 1 » du « Banc de registres ».
</p>
</details>
<!-- Le résultat de l'opération sera plus tard réinscrit dans le registre destination spécifié dans l'instruction.-->
<br>
&emsp;&nbsp;5\. Implémentez l'étape de lecture à partir du « Banc de registres ». N'oubliez pas d'intégrer votre « Banc de registres »  développé dans la tâche n°2 de ce projet. N'oubliez pas de connecter l'horloge !
<details close="">
<summary markdown="span">
6. En quoi le « Générateur d'Immédiat » (circuit `imm_gen.circ`) pourrait vous être utile ? 
</summary>
<p style="color: firebrick" markdown="span">
Pour l'instruction `addi`, le « Générateur d'Immédiat » prend 16 bits de l'instruction en entrée et produit un immédiat signé de 32 bits. Vous devez implémenter cette logique dans le sous-circuit du générateur d'immédiat !
</p>
</details>
<br>

#### **Etape 3 : Exécution de l'instruction**

L'étape d'exécution est l'endroit où le calcul de la plupart des instructions est effectué. C'est également ici que l'idée d'utiliser un module de contrôle sera introduite.

<details close="">
<summary markdown="span">
1. Pour l'instruction `addi`, que serait les données en entrée de votre UAL ? 
</summary>
<p style="color: firebrick" markdown="span">
Read Data 1 (rs1) du « Banc de registres » et la constante produite par le « Générateur d'Immédiat ».
</p>
</details>

<details close="">
<summary markdown="span">
2. A quoi sert `ALUSel` dans l'UAL ? 
</summary>
<p style="color: firebrick" markdown="span">
Il détermine quelle opération l'UAL doit effectuer.
</p>
</details>

<details close="">
<summary markdown="span">
3. Bien qu'il soit possible pour l'instant de simplement coller une constante pour `ALUSel`, pourquoi cela serait déconseillé si vous preniez en considération que d'autres instructions seront implémentées dans le futur ?
</summary>
<p style="color: firebrick" markdown="span">
Lors de l'implémentation de plus d'instructions, l'entrée `ALUSel` de l'UAL pourrait changer en fonction de l'opération demandée. Donc, on a besoin d'une sorte de circuit qui change la valeur de `ALUSel` en fonction de l'instruction en cours d'exécution.
</p>
</details>
<br>
&emsp;&nbsp;4\. Intégrez dans votre processeur l'UAL développée dans la tâche n°1 de ce projet et connectez correctement les entrées. Avez-vous besoin de connecter une horloge ? Pourquoi ou pourquoi pas ?
<br>

#### **Etape 4 : Lecture/écriture depuis/vers la mémoire de données (MEM)**

L'étape **MEM** est l'endroit où la mémoire de données peut être modifiée à l'aide des instructions de stockage de données et lue à l'aide des instructions de lecture de données. Comme l'instruction `addi` n'utilise pas la mémoire de données, nous pouvons ignorer cette partie du circuit pour l'instant et continuer avec l'étape suivante d'exécution.

#### **Etape 5 : Ecriture *éventuelle* dans le « Banc de registres » (WB)** 

L'étape d'écriture (WriteBack) est l'endroit où les résultats d'une opération doivent être sauvegardés dans un registre.

<details close="">
<summary markdown="span">
1. Est-ce que l'instruction `addi` requiert une écriture dans un registre ?
</summary>
<p style="color: firebrick" markdown="span">
OUI ! l'instruction `addi` prend la sortie d'un calcul d'addition dans l'UAL et la réécrit dans le « Banc de registres ».
</p>
</details>

&emsp;&nbsp;2\. Nous avons vu dans le cours que l'étape WB permet d'écrire dans le « Banc de registres » la sortie de l'UAL ou de la mémoire de données (MEM). Créons donc la phase d'écriture dans cette perspective même si nous nous interessant seulement à l'instruction `addi` pour l'instant. Comme seule une donnée à la fois peut être écrite dans le « Banc de registres » dans l'architecture MIPS, nous devons utiliser un MUX pour choisir laquelle des sorties de l'UAL ou de MEM (`READ_DATA`) à transmettre. Plus tard, lorsque vous implémenterez d'autres instructions dans la partie B du projet, vous devrez revoir l'implémentation de ce multiplexeur pour gérer plus de cas.
 
<details close="">
<summary markdown="span">
3. Que devons-nous utiliser comme entrée de sélection du MUX ? De quoi dépend l'entrée ?
</summary>
<p style="color: firebrick" markdown="span">
On devrait pouvoir choisir entre trois entrées MUX : (1) UAL, (2) MEM [`READ_DATA`] et (3) PC + 4 (quand est-ce on aura besoin de celui-là ?). Le signal de commande qui détermine laquelle de ces entrées est transmise au « Banc de registres » est appelé `WBSel`. Pour l'instant, WBSel devrait avoir une seule valeur - quelle qu'elle soit pour `addi`.
</p>
</details>

<details close="">
<summary markdown="span">
4. Maintenant que les entrées du MUX sont fixées, nous devons brancher sa sortie ! Où doit-elle être raccordée ?
</summary>
<p style="color: firebrick" markdown="span">
La sortie du MUX véhicule les données que vous souhaitez écrire dans le « Banc de registres », elle doit donc être raccordée à l'entrée `Write Data` du « Banc de registres ».
</p>
</details>

&emsp;&nbsp;5\. Il y a deux autres entrées sur le « Banc de registres » qui sont importantes pour l'écriture des données : `RegWEn` et `rd`. L'une d'entre elles devra être récupérée de l'étape de décodage d'instructions (ID) et l'autre correspond à un nouveau signal de commande que vous devez concevoir dans la partie B du projet. Veuillez finaliser l'étape de l'écriture en implémentant correctement ces entrées pour l'instruction `addi`.

Si vous avez effectué toutes les étapes correctement, vous devriez avoir un processeur à cycle unique qui fonctionne pour les instructions `addi`. Exécutez `python3 test_runner.py part_a addi_single` depuis le terminal et voyez si votre implémentation fonctionne correctement !


### Guide : Parallélisation (pipelining) de votre processeur 

Il est maintenant temps de transformer votre processeur à cycle unique en une version « pipeline » ! Pour ce projet, vous allez implémenter un pipeline en 2 étages, qui est encore conceptuellement similaire au pipeline en 5 étages couvert en classe. Les deux étages que vous mettrez en oeuvre sont les suivantes :

  1. Récupération d'instruction (PIF) : Une instruction est récupérée depuis la mémoire d'instructions.
  2. Exécution de l'instruction (PEX) : L'instruction est décodée, exécutée et validée (résultat sauvegardé). Il s'agit d'une combinaison des quatre étapes restantes d'un pipeline MIPS normal à cinq étages (ID, EX, MEM et WB).

Comme tout le contrôle et l'exécution de l'instruction sont gérés dans l'étape d'exécution, **votre processeur `addi` en pipeline sera plus ou moins indiscernable de la version à cycle unique, à l'exception de la latence de démarrage d'un cycle d'horloge**. Nous allons, cepandant, appliquer les concepts de conception du pipeline vus en cours afin de préparer notre processeur pour la partie B de ce projet.

Quelques points à considérer pour une conception du pipeline en deux étages :

  - Les étages PIF et PEX auront-ils des valeurs `PC` identiques ou différentes ?
  - Avez-vous besoin de stocker le `PC` entre les étages de pipelining ?

D'autre part, on remarquera un problème d'amorçage ici : pendant le premier cycle d'exécution, les registres introduits entre les différentes étapes du pipeline sont initialement (vides), mais le vide n'existe pas en hardware. Comment allons-nous gérérer cette première instruction fictive ? A quoi correspondrait le vide dans notre processeur ? C-à-d. à quelles valeurs devons-nous initialer les registres nouvellement introduits pour ne « **rien faire** » pendant le premier cycle d'exécution ?

Il arrive que Logisim remet automatiquement les registres à zéro lors de la réinitialisation; ce qui, pour notre problème de cpu en pipeline, simulera une instruction `nop` au démarrage ! Merci logisim ! N'oubliez pas d'aller dans **| Simulate -> Reset Simulation|** pour réinitialiser votre processeur.

Après avoir pipeliné votre processeur, vous devriez être en mesure de réussir le test `python3 test_runner.py part_a addi_pipelined`. Notez que le précédent test `python3 test_runner.py part_a addi_single` devrait échouer maintenant ( pourquoi ? Consultez les sorties de référence pour chaque test et réfléchissez aux effets du pipelining sur les différentes étapes ).


<!--{:start="7"}-->


## Comprendre les tests effectués

Chaque test des tests cpu inclus dans le code de démarrage est une copie du fichier `run.circ` et contient des instructions préalablement chargées dans sa mémoire d'instructions (`Instruction Memory`). Lorsque vous lancez logisim-evolution à partir de la ligne de commande, votre circuit est automatiquement mis en marche. L'éxécution est cadencée par l'horloge, le `PC` de votre processeur est mis à jour, l'instruction récupérée est traitée, et les valeurs de chacune des sorties du circuit de test sont imprimées sur le terminal.

Prenons l'exemple du test `cpu-addi-pipelined.circ` fourni pour le processeur en pipeline. le circuit contient trois instructions `addi` (`addi $t0, $0, 5`, `addi $t1, $t0, 7` et `addi $s0, $t0, 9`). Ouvrez `tests/part_a/addi_pipelined/ cpu-addi-pipelined.circ` dans Logisim Evolution et examinez de plus près les différentes parties du circuit de test. En haut, vous verrez l’endroit où le socle testeur `test_harness` est connecté aux sorties de débogage. Initialement, ces sorties sont toutes des UUUUU, mais cela ne devrait pas être le cas une fois votre circuit `cpu.circ` est implémenté.

Le socle `test_harness` prend en entrée le signal d'horloge (`clk`) et l'(`Instruction`) fournie par le module de mémoire d'(`Instruction Memory`). En sortie, le socle transmet pour affichage les valeurs des registres de débogage provenant de votre circuit de processeur `cpu.circ`. La sortie additionnelle `fetch_addr` transmet l'adresse de la prochaine instruction à lire à la mémoire d'instructions (`Instruction Memory`).

<div class="bs-callout bs-callout-danger">
  <p>Veillez à ne déplacer aucune des entrées/sorties de votre processeur, ni à ajouter des entrées/sorties supplémentaires. Cela modifiera la forme du sous-circuit du processeur et, par conséquent, les connexions dans les fichiers de test risquent de ne plus fonctionner correctement.</p>
</div>

Sous le socle test_harness, vous verrez la mémoire d'instructions contenant le code machine en hexadécimal des trois instructions `addi` testés (0x00500293, 0x00728313, 0x00928413). La mémoire d'instructions prend une entrée (appelée `fetch_addr`) et délivre l'instruction stockée à cette adresse. Dans MIPS, `fetch_addr` est une valeur de 32 bits, mais comme Logisim Evolution limite la taille des unités ROM à $$2^{16}$$, nous devons utiliser un séparateur pour récupérer seulement 14 bits de `fetch_addr` (en ignorant les deux bits les plus bas).

<details close="">
<summary markdown="span">
Pourquoi les deux bits LSB de l'adresse `fetch_addr` sont ignorés ? 
</summary>
<p style="color: firebrick" markdown="span">
Dans MIPS, les instructions sont récupérées mot-par-mot depuis la mémoire d'instructions. Donc, on a besoin de convertir `fetch_addr` qui est une adresse d'octets, en une adresse de mots en supprimant les deux bits les plus bas (On y reviendra dans le cours sur les caches).
</p>
</details>

<br>
Ainsi, quand le circuit de test est mis en marche, chaque tick de l'horloge pilote l'exécution du socle `test_harness` et  incrémente le compteur appelé `Time_Step` (ce compteur se trouve à droite de la mémoire d'instructions, faites un zoom-out dans Logisim s'il n'est pas visible sur votre écran). 

A chaque tick de l'horloge, la ligne de commande Logisim Evolution imprimera les valeurs de chacune de vos sorties de débogage vers le terminal. L'horloge continuera à tourner jusqu'à ce que `Time_Step` soit égal à la constante d'arrêt pour ce circuit de test (pour ce fichier de test en particulier, la constante d'arrêt est 5). 

Enfin, nous comparons la sortie de votre circuit au résultat attendu; si la sortie de votre circuit est différente, vous échouerez au test.

### Les tests `addi`

Deux tests pour l'instruction `addi` sont fournis dans le kit de démarrage : un test pour le processeur à cycle unique et un test pour le processeur en pipeline. Vous pouvez exécuter le test pour la version « pipeline » avec la commande suivante (remplacez `pipelined` par `single` pour tester la version « cycle unique ») :

```bash
$ python3 test_runner.py part_a addi_pipelined # For a pipelined CPU
```

Vous pouvez consulter les fichiers .s (MIPS) et .hex (code machine) pour le test dans `tests/part_a/addi_pipelined/inputs`.

Le script Python `binary_to_hex_cpu.py` pour faciliter l'interprétation de votre sortie est également inclus. Ce script fonctionne comme les scripts `binary_to_hex_alu.py` et `binary_to_hex_regfile.py` utilisés dans les tâches de conception de l'UAL et du « Banc de registres » (Tâches n°1 et n°2). Pour utiliser le script, exécutez:

```bash
$ cd tests/part_a/addi_pipelined
$ python3 binary_to_hex_cpu.py student_output/CPU-addi-pipelined-student.out
```

ou, pour visualiser la sortie de référence, exécutez:

```bash
$ cd tests/part_a/addi_pipelined
$ python3 binary_to_hex_cpu.py reference_output/CPU-addi-pipelined-ref.out
```

# Soumettre votre devoir 

Assurez-vous à nouveau que vous n'avez pas déplacé/modifié vos ports d'entrée/sortie et que vos circuits s'insèrent sans problème dans les socles de test fournis.

Pour l'évaluation de cette partie du projet, vous devez soumettre un fichier **zippé** contenant tous les circuits que vous deviez implémenter. C.-à-d. les circuits **alu.circ**, **regfile.circ**, **imm_gen.circ**, **control_logic.circ** et **cpu.circ**. 

```bash
votre_fichier.zip
 ├── alu.circ
 ├── regfile.circ
 ├── imm_gen.circ
 ├── control_logic.circ
 └── cpu.circ
 ```

Par exemple, pour mettre les fichiers **file1.circ** et **file2.circ** dans un fichier zip **votre_fichier.zip** :
  1. Ouvrez une console (Ctrl-Alt-T sous Ubuntu), puis allez dans le répertoire contenant les fichiers **file1.circ** et **file2.circ**. 
  2. Tapez la commande :
     ```bash
     zip fichier.zip  file1.circ file2.circ
     ```

Soumettez ensuite le fichier résultat **votre_fichier.zip** à l'évaluateur automatique. Cette partie du projet utilisera les mêmes fichiers de test déjà fournis dans le kit de démarrage pour l'évaluation de votre travail. Il n'y a pas de test caché !
